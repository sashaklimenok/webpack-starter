`
Все числа в JavaScript хранятся в 64-битном формате IEEE-754, 
который также называют «числа с плавающей точкой двойной точности» (double precision floating point numbers).
`

let ms = 0.0000001; //одна миллионная секунды
let ms = 1e-6; // шесть нулей, слева от 1

//-----------------------------------------------------------------------------------------------------------

`Шестнадцатеричные, двоичные и восьмеричные числа`

`Шестнадцатеричные числа широко используются в JavaScript для представления цветов, 
кодировки символов и многого другого. Естественно, есть короткий стиль записи: 0x, после которого указывается число.`

let hex = 0xff; // 255


`Умножить и разделить.
Например, чтобы округлить число до второго знака после запятой, мы можем умножить число на 100, вызвать функцию округления и разделить обратно.`

let num = 1.23456;
console.log(Math.floor(num * 100) / 100); // 1.23456 -> 123.456 -> 123 -> 1.23

let num = 12.34;
console.log(num.toFixed(1)); // "12.3"

`Мы можем преобразовать полученное значение в число,
используя унарный оператор + или Number(), 
пример с унарным оператором: +num.toFixed(5).`



//-----------------------------------------------------------------------------------------------------------

`ошибка в точности вычислений для 
чисел с плавающей точкой сохраняется в любом другом языке, где используется формат IEEE 754, включая PHP, Java, C, Perl, Ruby.`
`Можно ли обойти проблему? Конечно, наиболее надёжный способ — это округлить результат используя метод toFixed(n):`

let sum = 0.1 + 0.2;
sum.toFixed(2); // 0.30


//-----------------------------------------------------------------------------------------------------------


// Привет! Я – число, растущее само по себе!
9999999999999999; // покажет 10000000000000000

`Причина та же – потеря точности. Из 64 бит, 
отведённых на число, сами цифры числа занимают до 52 бит,
остальные 11 бит хранят позицию десятичной точки и один бит – знак. 
Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.
`
//-----------------------------------------------------------------------------------------------------------

isNaN(NaN); // true
isFinite("15"); // true


`Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.

Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.
Во всех других случаях Object.is(a, b) идентичен a === b.`


parseInt('100px')  // 100
parseFloat('12.5em'); // 12.5

parseInt('12.3'); // 12, вернётся только целая часть
parseFloat('12.3.4')  // 12.3, произойдёт остановка чтения на второй точке


function readNumber() {
    let num;

    do {
        num = prompt("Введите число", 0);
    } while (!isFinite(num));

    if (num === null || num === '') return null;

    return +num;
}

alert(`Число: ${readNumber()}`);


function randomInteger(min, max) {
    // получить случайное число от (min-0.5) до (max+0.5)
    let rand = min - 0.5 + Math.random() * (max - min + 1);
    return Math.round(rand);
}

alert(randomInteger(1, 3));

